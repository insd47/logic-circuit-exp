작성한 코드에 다음과 같은 변형을 가하고 싶어.

- `tlcd_controller.v`: 16x2의 Text LCD를 제어하는 모듈이야. 현재 입력 핀에 각 위치마다 따로 입력하도록 되어있는데, 이를 두개의 String으로 나누려고 해. (윗줄, 아랫줄)
  따라서 변경될 입력 핀은 다음과 같아:
  - RESETN: 리셋 신호
  - CLK: 클록 신호
  - TEXT_STRING_UPPER: 윗줄에 표시할 텍스트 문자열 (16바이트)
  - TEXT_STRING_LOWER: 아랫줄에 표시할 텍스트 문자열 (16바이트)

현재 `tlcd_controller.v` 코드는 다음과 같아:
```verilog
module tlcd_controller(
    input wire RESETN,          // Low active reset
    input wire CLK,             // System clock
    output wire TLCD_E,         // LCD E pin
    output reg TLCD_RS,         // LCD RS pin
    output reg TLCD_RW,         // LCD RW pin
    output reg [7:0] TLCD_DATA, // LCD data bus
    input wire [7:0] VALUE_1_1, VALUE_1_2, VALUE_1_3, VALUE_1_4, VALUE_1_5, VALUE_1_6, VALUE_1_7, VALUE_1_8,
    input wire [7:0] VALUE_1_9, VALUE1_10, VALUE1_11, VALUE1_12, VALUE1_13, VALUE1_14, VALUE1_15, VALUE1_16,
    input wire [7:0] VALUE_2_1, VALUE_2_2, VALUE_2_3, VALUE_2_4, VALUE_2_5, VALUE_2_6, VALUE_2_7, VALUE_2_8,
    input wire [7:0] VALUE_2_9, VALUE2_10, VALUE2_11, VALUE2_12, VALUE2_13, VALUE2_14, VALUE2_15, VALUE2_16
);

    // 상태 정의
    reg [2:0] STATE;
    parameter DELAY = 3'b000, FUNCTION_SET = 3'b001,
              ENTRY_MODE = 3'b010, DISP_ONOFF = 3'b011,
              LINE1 = 3'b100, LINE2 = 3'b101,
              DELAY_T = 3'b110, CLEAR_DISP = 3'b111;

    integer CNT;

    // LCD_E 핀은 CLK에 직접 연결
    assign TLCD_E = CLK;

    // 상태 머신
    always @(posedge RESETN or posedge CLK) begin
        if (RESETN)
            STATE <= DELAY;
        else begin
            case (STATE)
                DELAY:
                    if (CNT == 70) STATE <= FUNCTION_SET;
                FUNCTION_SET:
                    if (CNT == 30) STATE <= DISP_ONOFF;
                DISP_ONOFF:
                    if (CNT == 30) STATE <= ENTRY_MODE;
                ENTRY_MODE:
                    if (CNT == 30) STATE <= LINE1;
                LINE1:
                    if (CNT == 16) STATE <= LINE2;
                LINE2:
                    if (CNT == 16) STATE <= DELAY_T;
                DELAY_T:
                    if (CNT == 100) STATE <= CLEAR_DISP;
                CLEAR_DISP:
                    if (CNT == 30) STATE <= LINE1;
                default:
                    STATE <= DELAY;
            endcase
        end
    end

    // 카운터
    always @(posedge RESETN or posedge CLK) begin
        if (RESETN)
            CNT <= 0;
        else begin
            case (STATE)
                DELAY:
                    if (CNT >= 70) CNT <= 0;
                    else CNT <= CNT + 1;
                FUNCTION_SET:
                    if (CNT >= 30) CNT <= 0;
                    else CNT <= CNT + 1;
                DISP_ONOFF:
                    if (CNT >= 30) CNT <= 0;
                    else CNT <= CNT + 1;
                ENTRY_MODE:
                    if (CNT >= 30) CNT <= 0;
                    else CNT <= CNT + 1;
                LINE1:
                    if (CNT >= 16) CNT <= 0;
                    else CNT <= CNT + 1;
                LINE2:
                    if (CNT >= 16) CNT <= 0;
                    else CNT <= CNT + 1;
                DELAY_T:
                    if (CNT >= 100) CNT <= 0;
                    else CNT <= CNT + 1;
                CLEAR_DISP:
                    if (CNT >= 30) CNT <= 0;
                    else CNT <= CNT + 1;
                default:
                    CNT <= 0;
            endcase
        end
    end

    // LCD 제어 신호 및 데이터 설정
    always @(posedge RESETN or posedge CLK) begin
        if (RESETN) begin
            TLCD_RS <= 1'b1;
            TLCD_RW <= 1'b1;
            TLCD_DATA <= 8'b00000000;
        end else begin
            case (STATE)
                FUNCTION_SET: begin
                    TLCD_RS <= 1'b0; TLCD_RW <= 1'b0;
                    TLCD_DATA <= 8'b00111100; // Function Set
                end
                DISP_ONOFF: begin
                    TLCD_RS <= 1'b0; TLCD_RW <= 1'b0;
                    TLCD_DATA <= 8'b00001100; // Display On, Cursor Off
                end
                ENTRY_MODE: begin
                    TLCD_RS <= 1'b0; TLCD_RW <= 1'b0;
                    TLCD_DATA <= 8'b00000110; // Entry Mode Set
                end
                LINE1: begin
                    TLCD_RW <= 1'b0;
                    case (CNT)
                        0: begin
                            TLCD_RS <= 1'b0;
                            TLCD_DATA <= 8'b10000000; // Line 1 시작 주소
                        end
                        1: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_1; end
                        2: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_2; end
                        3: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_3; end
                        4: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_4; end
                        5: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_5; end
                        6: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_6; end
                        7: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_7; end
                        8: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_8; end
                        9: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_1_9; end
                        10: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE1_10; end
                        11: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE1_11; end
                        12: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE1_12; end
                        13: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE1_13; end
                        14: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE1_14; end
                        15: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE1_15; end
                        16: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE1_16; end
                        default: begin TLCD_RS <= 1'b1; TLCD_DATA <= 8'b00100000; end
                    endcase
                end
                LINE2: begin
                    TLCD_RW <= 1'b0;
                    case (CNT)
                        0: begin
                            TLCD_RS <= 1'b0;
                            TLCD_DATA <= 8'b11000000; // Line 2 시작 주소
                        end
                        1: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_1; end
                        2: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_2; end
                        3: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_3; end
                        4: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_4; end
                        5: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_5; end
                        6: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_6; end
                        7: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_7; end
                        8: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_8; end
                        9: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE_2_9; end
                        10: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE2_10; end
                        11: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE2_11; end
                        12: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE2_12; end
                        13: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE2_13; end
                        14: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE2_14; end
                        15: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE2_15; end
                        16: begin TLCD_RS <= 1'b1; TLCD_DATA <= VALUE2_16; end
                        default: begin TLCD_RS <= 1'b1; TLCD_DATA <= 8'b00100000; end
                    endcase
                end
                DELAY_T: begin
                    TLCD_RS <= 1'b0; TLCD_RW <= 1'b0;
                    TLCD_DATA <= 8'b00000010; // Return Home
                end
                CLEAR_DISP: begin
                    TLCD_RS <= 1'b0; TLCD_RW <= 1'b0;
                    TLCD_DATA <= 8'b00000001; // Clear Display
                end
                default: begin
                    TLCD_RS <= 1'b1; TLCD_RW <= 1'b1;
                    TLCD_DATA <= 8'b00000000;
                end
            endcase
        end
    end

endmodule
```

tlcd_controller에 의존하는 custom_font_loader와 W11 모듈은 다음과 같아. 해당 모듈도 변경사항에 맞게 수정해 줘.

```verilog
module W11 (
    input wire CLK,
    input wire RESETN,
    output wire TLCD_E,
    output wire TLCD_RS,
    output wire TLCD_RW,
    output wire [7:0] TLCD_DATA
);

    wire [2:0] font_loader_state;
    wire TLCD_E_font, TLCD_RS_font, TLCD_RW_font;
    wire [7:0] TLCD_DATA_font;

    wire TLCD_E_text, TLCD_RS_text, TLCD_RW_text;
    wire [7:0] TLCD_DATA_text;

    // 텍스트 LCD 컨트롤러
    tlcd_controller lcd_inst (
        .RESETN(RESETN),
        .CLK(CLK),
        .TLCD_E(TLCD_E_text),
        .TLCD_RS(TLCD_RS_text),
        .TLCD_RW(TLCD_RW_text),
        .TLCD_DATA(TLCD_DATA_text),
        .VALUE_1_1("H"), .VALUE_1_2("e"), .VALUE_1_3("l"), .VALUE_1_4("l"),
        .VALUE_1_5("o"), .VALUE_1_6(","), .VALUE_1_7(" "), .VALUE_1_8("W"),
        .VALUE_1_9("o"), .VALUE1_10("r"), .VALUE1_11("l"), .VALUE1_12("d"),
        .VALUE1_13("!"), .VALUE1_14(" "), .VALUE1_15(" "), .VALUE1_16(" "),
        .VALUE_2_1(8'h00), .VALUE_2_2(8'h01), .VALUE_2_3(8'h02), .VALUE_2_4(8'h03),
        .VALUE_2_5(8'h04), .VALUE_2_6(" "), .VALUE_2_7(" "), .VALUE_2_8(" "),
        .VALUE_2_9(" "), .VALUE2_10(" "), .VALUE2_11(" "), .VALUE2_12(" "),
        .VALUE2_13(" "), .VALUE2_14(" "), .VALUE2_15(" "), .VALUE2_16(" ")
    );

    // 커스텀 폰트 로더
    custom_font_loader font_loader (
        .RESETN(RESETN),
        .CLK(CLK),
        .TLCD_E(TLCD_E_font),
        .TLCD_RS(TLCD_RS_font),
        .TLCD_RW(TLCD_RW_font),
        .TLCD_DATA(TLCD_DATA_font),
        .STATE(font_loader_state) // font_loader의 상태 출력
    );

    // LCD 제어 신호 선택
    assign TLCD_E = (font_loader_state != 3'b010) ? TLCD_E_font : TLCD_E_text; // DONE 상태 확인
    assign TLCD_RS = (font_loader_state != 3'b010) ? TLCD_RS_font : TLCD_RS_text;
    assign TLCD_RW = (font_loader_state != 3'b010) ? TLCD_RW_font : TLCD_RW_text;
    assign TLCD_DATA = (font_loader_state != 3'b010) ? TLCD_DATA_font : TLCD_DATA_text;

endmodule
```

```verilog
module custom_font_loader(
    input wire RESETN,
    input wire CLK,
    output wire TLCD_E,
    output reg TLCD_RS,
    output reg TLCD_RW,
    output reg [7:0] TLCD_DATA,
    output reg [2:0] STATE // 현재 상태를 외부로 노출
);

    parameter INIT = 3'b000, LOAD_FONT = 3'b001, DONE = 3'b010;

    integer CNT;
    reg [5:0] cf_addr; // 커스텀 폰트 주소
    reg [7:0] custom_font [0:39]; // 5*8=40 bytes

    initial begin
        // 커스텀 폰트 데이터 초기화
        custom_font[0] = 8'b00110;
        custom_font[1] = 8'b00111; // CF1
        custom_font[2] = 8'b00100;
        custom_font[3] = 8'b00110;
        custom_font[4] = 8'b01100;
        custom_font[5] = 8'b11100;
        custom_font[6] = 8'b11100;
        custom_font[7] = 8'b10100;
        custom_font[7] = 8'b10100;
        // CF2
        custom_font[8] = 8'b01100;
        custom_font[9] = 8'b01110;
        custom_font[10]= 8'b01000;
        custom_font[11]= 8'b01110;
        custom_font[12]= 8'b01100;
        custom_font[13]= 8'b11100;
        custom_font[14]= 8'b11100;
        custom_font[15]= 8'b01000;
        // CF3
        custom_font[16]= 8'b00110;
        custom_font[17]= 8'b00111;
        custom_font[18]= 8'b01110;
        custom_font[19]= 8'b11110;
        custom_font[20]= 8'b11100;
        custom_font[21]= 8'b01000;
        custom_font[22]= 8'b00000;
        custom_font[23]= 8'b00000;
        // CF4
        custom_font[24]= 8'b00100;
        custom_font[25]= 8'b10100;
        custom_font[26]= 8'b10101;
        custom_font[27]= 8'b10101;
        custom_font[28]= 8'b01101;
        custom_font[29]= 8'b00110;
        custom_font[30]= 8'b00100;
        custom_font[31]= 8'b00100;
        // CF5
        custom_font[32]= 8'b00000;
        custom_font[33]= 8'b00100;
        custom_font[34]= 8'b00101;
        custom_font[35]= 8'b10101;
        custom_font[36]= 8'b10101;
        custom_font[37]= 8'b10110;
        custom_font[38]= 8'b01100;
        custom_font[39]= 8'b00100;
    end

    assign TLCD_E = CLK; // E 핀은 클럭에 직접 연결

    always @(posedge RESETN or posedge CLK) begin
        if (RESETN) begin
            STATE <= INIT;
            CNT <= 0;
            cf_addr <= 0;
        end else begin
            case (STATE)
                INIT: begin
                    STATE <= LOAD_FONT;
                end
                LOAD_FONT: begin
                    if (cf_addr < 6'd40) begin
                        if (CNT == 0) begin
                            if (cf_addr[2:0] == 3'd0) begin
                                TLCD_RS <= 1'b0;
                                TLCD_RW <= 1'b0;
                                TLCD_DATA <= 8'b01000000 | (cf_addr[5:3] << 3); // CGRAM 주소 설정
                            end else begin
                                TLCD_RS <= 1'b1;
                                TLCD_RW <= 1'b0;
                                TLCD_DATA <= custom_font[cf_addr];
                            end
                            CNT <= CNT + 1;
                        end else if (CNT == 1) begin
                            CNT <= 0;
                            cf_addr <= cf_addr + 1;
                        end
                    end else begin
                        STATE <= DONE;
                    end
                end
                DONE: begin
                    // 커스텀 폰트 로딩 완료 상태
                end
                default: STATE <= DONE;
            endcase
        end
    end

endmodule
```