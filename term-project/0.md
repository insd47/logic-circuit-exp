# Text LCD 공룡 게임

## 소개
Xilinx FPGA 보드에 Text LCD로 동작하는 공룡 게임을 구현한다.

## 구성 요소
- Text LCD (16x2, 공룡 및 장애물 출력)
- Keypad (0~9, #, * 키를 입력할 수 있음)
- 8자리 7-segment LED (점수 표시)

## 상태 관리
- 구동 즉시 폰트를 CGRAM에 로드 후, 게임 시작 화면 출력,
  7-Segment에는 `DINOSAUR`를 출력하고 Text LCD에는 아래의 문구를 출력한다.
  (D는 커스텀 공룡 폰트 표현)
    ```
        PRESS ANY KEY
    D   TO START GAME
    ```
- 게임 시작 시, 공룡이 점프하며 장애물을 피한다. 장애물은 2-bit x 16 shift register 1개로 관리하며 (바닥 장애물), 공룡의 점프 상태에 따라 피격을 판정한다.
  2개의 비트를 사용하는 이유는 장애물의 모양을 2가지로 나누어 표시하기 위해서이다.
- 기기의 클럭은 1Mhz로 가정하고, 장애물의 이동은 0.25초에 한 번씩 이루어진다. 
  공룡음 #을 제외한 키패드 버튼 입력으로 점프할 수 있다. 공룡의 점프는 0.75초동안 유지되며 이 동안 상단 행으로 이동한다. (점프 상태 또한 shift register 1x3 등으로 관리하면 된다.)
  게임 진행 중 점수는 7-Segment에 표시하며, 장애물이 한 칸 이동할 때마다 점수가 1씩 증가한다.
- 0~15번 칸 중 장애물이 등장 가능한 칸은 공룡이 존재하는 1번째 칸을 제외한 모든 칸이다.
  장애물은 15번째 칸에서부터 생성되며 0.25초에 한 번씩 이동하여 0번째 칸까지 이동한다.
  장애물이 등장하는 칸의 최소 간격을 설정하기 위해 5~15번 칸에 장애물이 존재할 때에는 장애물을 생성하지 않으며,
  이후 3/4 확률의 의사 난수를 이용하여 장애물을 생성한다.
- register 변경, 점프 상태의 변경, LCD 렌더링은 0.25초의 Rising Edge에서 이루어진다.
  특히 입력의 경우 0.25초 내에 한 번이라도 입력이 있었다면 다음 Rising Edge에 반영된다.
- 공룡이 장애물에 부딪히거나 #버튼을 클릭하면 게임 오버 상태로 전환하고, 점수 집계를 중단한다.
  이 때 7-Segment에는 `GAME OVER`를 출력하고 Text LCD에는 아래의 문구를 출력한다.
    ```
        GAME OVER
    D   SCORE: 1234
    ```
  게임 시작과 마찬가지로 게임 오버 상태에서도 키패드의 아무 키나 입력해서 게임을 재시작할 수 있다.

## 커스텀 폰트
모든 폰트는 5x8 사이즈이고, ASCII 커스텀 대역을 사용한다.
기기 구동 시 아래의 폰트를 CGRAM에 로드한다.

### 1. 공룡 걷기 (1)
```
b00110
b00111
b00100
b00110
b01100
b11100
b11100
b10100
```
### 2. 공룡 걷기 (2)
```
b01100
b01110
b01000
b01110
b01100
b11100
b11100
b01000
```
### 3. 공룡 점프
```
b00110
b00111
b01110
b11110
b11100
b01000
b00000
b00000
```
### 4. 장애물 (1)
```
b00100
b10100
b10101
b10101
b01101
b00110
b00100
b00100
```
### 5. 장애물 (2)
```
b00000
b00100
b00101
b10101
b10101
b10110
b01100
b00100
```

## 작업
1. 제공된 모듈을 참고하여 `shift_reg1x16.v` 등 필요 모듈을 작성하시오.
2. 제공된 모듈을 참고하여 Text LCD를 제어하는 모듈을 작성하시오.
3. 제공하는 파일을 잘 조합하여 동작하는 공룡 게임을 구현하시오. 다만 편의에 따라 몇 가지의 모듈을 추가 작성하셔도 무방하다.

## 입력
- Keypad[0..9]: FPGA 보드의 키패드이다. 0~9의 입력을 받는다.
- Keypad[#]: FPGA 보드의 키패드 중 # 버튼이다. 공룡이 점프한다.
- CLK: FPGA 보드의 Clock 값이다.
- RST: Reset 스위치. 해당 버튼이 High 상태일 때 (1) Shift Register가 사용 가능해진다.

## 출력
- SegA ~ SegG : 7 Segment 출력
- Com[0..3] : 출력할 Segment를 선택함. 0일 때 해당 세그먼트가 선택되어 출력됨.
- TLCD_E: Text LCD의 Enable 신호
- TLCD_RS: Text LCD의 RS 신호
- TLCD_RW: Text LCD의 RW 신호
- TLCD_DATA[7:0]: Text LCD의 데이터 출력.

## 주의사항
- 제공된 입출력 핀만을 최대한 사용하여라. 만약 이만을 사용해 구현이 불가능하다면, 추가적인 핀을 사용할 수 있다. 이는 따로 명시해야 한다.
- FPGA에 사람이 버튼을 입력할 경우 시스템 clock보다 속도가 훨씬 느리기 때문에 버튼을 한번 눌러도 여러 번 입력이 됨
  trigger.v는 Shift register를 사용해서 입력이 0이었다가 다음 클럭에 1이 되는 순간에만 트리거링이 되도록 구현되어 있음
  제공되는 trigger모듈을 사용해서 입력을 단일 입력으로 바꾸어 사용

## 사용 가능한 Verilog 모듈
제공한 모듈을 모두 사용할 필요는 없으며, 필요에 따라 모듈을 추가 작성하여도 됨.

### shift_reg4x4.v
```verilog
module shift_reg4x4(
input [3:0] Din,
input CLK,
input RST,
input CE,
output [3:0] Q0,
output [3:0] Q1,
output [3:0] Q2,
output [3:0] Q3
);

    wire [3:0] stage0_out;
    wire [3:0] stage1_out;
    wire [3:0] stage2_out;
    wire [3:0] stage3_out;

    reg4 reg0 (
        .Din(Din),
        .Dout(stage3_out),
        .CLK(CLK),
        .RST(RST),
        .CE(CE)
    );

    reg4 reg1 (
        .Din(stage3_out),
        .Dout(stage2_out),
        .CLK(CLK),
        .RST(RST),
        .CE(CE)
    );

    reg4 reg2 (
        .Din(stage2_out),
        .Dout(stage1_out),
        .CLK(CLK),
        .RST(RST),
        .CE(CE)
    );

    reg4 reg3 (
        .Din(stage1_out),
        .Dout(stage0_out),
        .CLK(CLK),
        .RST(RST),
        .CE(CE)
    );

    assign Q0 = stage0_out;
    assign Q1 = stage1_out;
    assign Q2 = stage2_out;
    assign Q3 = stage3_out;

endmodule
```

### mux_4bit_2x1.v
```verilog
module mux_4bit_2x1(
input [3:0] d0,
input [3:0] d1,
input sel,
output [3:0] y
);

    assign y = sel ? d1 : d0;

endmodule
```

### count4.v
```verilog
module count4(
input CLK,
input RST,
output reg [1:0] Q
);

    always @(posedge CLK or posedge RST) begin
        if (RST)
            Q <= 2'b00;
        else
            Q <= Q + 1;
    end

endmodule
```

### b2seg.v
```verilog
module b2seg(
input [3:0] Bin,
output reg SegA,
output reg SegB,
output reg SegC,
output reg SegD,
output reg SegE,
output reg SegF,
output reg SegG
);

    always @(*) begin
        case (Bin)
            4'b0000: begin
                SegA = 1; SegB = 1; SegC = 1; SegD = 1; SegE = 1; SegF = 1; SegG = 0;
            end
            4'b0001: begin
                SegA = 0; SegB = 1; SegC = 1; SegD = 0; SegE = 0; SegF = 0; SegG = 0;
            end
            4'b0010: begin
                SegA = 1; SegB = 1; SegC = 0; SegD = 1; SegE = 1; SegF = 0; SegG = 1;
            end
            4'b0011: begin
                SegA = 1; SegB = 1; SegC = 1; SegD = 1; SegE = 0; SegF = 0; SegG = 1;
            end
            4'b0100: begin
                SegA = 0; SegB = 1; SegC = 1; SegD = 0; SegE = 0; SegF = 1; SegG = 1;
            end
            4'b0101: begin
                SegA = 1; SegB = 0; SegC = 1; SegD = 1; SegE = 0; SegF = 1; SegG = 1;
            end
            4'b0110: begin
                SegA = 1; SegB = 0; SegC = 1; SegD = 1; SegE = 1; SegF = 1; SegG = 1;
            end
            4'b0111: begin
                SegA = 1; SegB = 1; SegC = 1; SegD = 0; SegE = 0; SegF = 0; SegG = 0;
            end
            4'b1000: begin
                SegA = 1; SegB = 1; SegC = 1; SegD = 1; SegE = 1; SegF = 1; SegG = 1;
            end
            4'b1001: begin
                SegA = 1; SegB = 1; SegC = 1; SegD = 1; SegE = 0; SegF = 1; SegG = 1;
            end
            default: begin
                SegA = 0; SegB = 0; SegC = 0; SegD = 0; SegE = 0; SegF = 0; SegG = 0;
            end
        endcase
    end

endmodule
```

### d2b.v
```verilog
module d2b(
input [9:0] Keypad,
output reg [3:0] Bin
);

    always @(*) begin
        Bin = 4'b0000;
        if (Keypad[0]) begin
            Bin = 4'b0000;
        end else if (Keypad[1]) begin
            Bin = 4'b0001;
        end else if (Keypad[2]) begin
            Bin = 4'b0010;
        end else if (Keypad[3]) begin
            Bin = 4'b0011;
        end else if (Keypad[4]) begin
            Bin = 4'b0100;
        end else if (Keypad[5]) begin
            Bin = 4'b0101;
        end else if (Keypad[6]) begin
            Bin = 4'b0110;
        end else if (Keypad[7]) begin
            Bin = 4'b0111;
        end else if (Keypad[8]) begin
            Bin = 4'b1000;
        end else if (Keypad[9]) begin
            Bin = 4'b1001;
        end
    end

endmodule
```

### PNU_AND2.v
```verilog
module PNU_AND2(i1, i2, o1);
input i1, i2;
output o1;
assign o1 = i1 & i2;
endmodule
```

### PNU_DFF.v
```verilog
module PNU_DFF(D, clock, reset, Q);
input D, clock, reset;
output Q;
reg Q;

    always@(posedge clock or posedge reset)
        if( reset ) begin
            Q <= 1'b0;
        end else begin
            Q <= D;
        end
endmodule

### PNU_MUX2.v
verilog
module PNU_MUX2(i1, i2, e1, o1);
input i1, i2, e1;
output o1;
assign o1 = e1 ? i2 : i1;
endmodule

### PNU_NOT.v
verilog
module PNU_NOT(i1, o1);
input i1;
output o1;
assign o1=~i1;
endmodule
```

### reg4.v
```verilog
module reg4(Dout,Din,CLK,RST,CE);

output [3:0] Dout;
input [3:0] Din;
input CLK;
input RST;
input CE;

wire [3:0] b0;
wire [3:0] b1;
wire  w4;
wire  w9;
wire  w16;
wire  w17;
wire  w18;
wire  w22;
wire  w25;
wire  b1_3_w10;
wire  b1_2_w19;
wire  b1_1_w20;
wire  b1_0_w21;
wire  b0_3;
wire  b0_3_w23;
wire  b0_2;
wire  b0_2_w24;
wire  b0_1;
wire  b0_1_w26;
wire  b0_0;
wire  b0_0_w27;

assign Dout = b0;
assign b1 = Din;
assign w4 = CLK;
assign w25 = RST;
assign w22 = CE;

assign b0[3] = b0_3;
assign b0[2] = b0_2;
assign b0[1] = b0_1;
assign b0[0] = b0_0;

assign b1_3_w10 = {b1[3]};
assign b1_2_w19 = {b1[2]};
assign b1_1_w20 = {b1[1]};
assign b1_0_w21 = {b1[0]};
assign b0_3_w23 = {b0[3]};
assign b0_2_w24 = {b0[2]};
assign b0_1_w26 = {b0[1]};
assign b0_0_w27 = {b0[0]};

PNU_DFF
s0 (
.clock(w4),
.D(w9),
.Q(b0_3),
.reset(w25));

PNU_DFF
s1 (
.clock(w4),
.D(w18),
.Q(b0_2),
.reset(w25));

PNU_DFF
s3 (
.clock(w4),
.D(w16),
.reset(w25),
.Q(b0_0));

PNU_MUX2
s4 (
.o1(w9),
.i2(b1_3_w10),
.e1(w22),
.i1(b0_3_w23));

PNU_DFF
s2 (
.clock(w4),
.D(w17),
.reset(w25),
.Q(b0_1));

PNU_MUX2
s5 (
.o1(w18),
.i2(b1_2_w19),
.e1(w22),
.i1(b0_2_w24));

PNU_MUX2
s6 (
.o1(w17),
.i2(b1_1_w20),
.e1(w22),
.i1(b0_1_w26));

PNU_MUX2
s7 (
.o1(w16),
.i2(b1_0_w21),
.e1(w22),
.i1(b0_0_w27));

endmodule

### trigger.v
verilog
module trigger(sig_in,trigger,clk,rst);

input sig_in;
output trigger;
input clk;
input rst;

wire  w1;
wire  w2;
wire  w3;
wire  w5;
wire  w4;
wire  w6;
wire  w7;

assign w1 = sig_in;
assign trigger = w7;
assign w2 = clk;
assign w3 = rst;

PNU_DFF
s0 (
.D(w1),
.clock(w2),
.reset(w3),
.Q(w4));

PNU_DFF
s1 (
.clock(w2),
.reset(w3),
.Q(w5),
.D(w4));

PNU_AND2
s2 (
.i1(w4),
.i2(w6),
.o1(w7));

PNU_NOT
s3 (
.i1(w5),
.o1(w6));

endmodule
```
