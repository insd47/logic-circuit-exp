# FPGA Text LCD Controller

## 소개

이번 과제에서는 FPGA 보드의 Text LCD를 제어하는 모듈을 작성해야 해.
너는 아래의 "할 일"을 참고해서 각 verilog 코드를 **전부 다** 작성해서 Full Code를 제공해야 해.
설명 및 주석은 한국어로 달아줘.

## 할 일

1. `trigger.v` 모듈은 `PNU_DFF.v`, `PNU_NOT.v`, `PNU_AND2.v` 모듈에 의존하는데, 이 중 `PNU_NOT.v`와 `PNU_AND2.v`는 System Verilog의 `!`
   연산자와 `&&` 연산자로 대체할 수 있다. 이에 대한 대체 코드를 작성하라.
2. `tlcd_controller.v` 모듈을 작성하라. 이 모듈은 16x2의 Text LCD를 제어하며, 커스텀 폰트 출력이 가능하다. 커스텀 폰트 출력은 따로 목록을 작성해 두겠다. 이 모듈은
   `trigger.v` 모듈에 의존하지 않는다. (독립된 두 가지의 과제임) 이 모듈의 인터페이스는 다음과 같다:
   ```verilog
   module tlcd_controller (
       input wire clk,                          // 시스템 클록
       input wire rst,                          // 리셋 신호
       input wire [8*32-1:0] text_string,       // 표시할 텍스트 문자열 (16x2 문자, 총 32바이트)
       output reg TLCD_RS,                      // LCD의 RS 핀
       output reg TLCD_RW,                      // LCD의 RW 핀
       output reg TLCD_E,                       // LCD의 E 핀
       output reg [7:0] TLCD_DATA               // LCD의 데이터 핀
   );
   ```
3. `tlcd_controller.v` 모듈을 활용하여 아래의 텍스트를 출력하는 `W11.v` 모듈을 작성하라
    ```
    Hello, World!
    {CF1}{CF2}{CF3}{CF4}{CF5}
    ```
   (단, `{CF1}`부터 `{CF5}`까지는 커스텀 폰트를 의미한다)

## 참고 자료

### Text LCD 제어 명령

| Instruction                   | RS | RW | DB7   | DB6    | DB5    | DB4    | DB3    | DB2    | DB1    | DB0    |
|-------------------------------|----|----|-------|--------|--------|--------|--------|--------|--------|--------|
| Display Clear                 | 0  | 0  | 0     | 0      | 0      | 0      | 0      | 0      | 0      | 1      |
| Cursor Home                   | 0  | 0  | 0     | 0      | 0      | 0      | 0      | 0      | 1      | X      |
| Entry Mode Set                | 0  | 0  | 0     | 0      | 0      | 0      | 0      | 1      | I/D    | S      |
| Display On/Off Control        | 0  | 0  | 0     | 0      | 0      | 0      | 1      | D      | C      | B      |
| Cursor/Display Shift          | 0  | 0  | 0     | 0      | 0      | 1      | S/C    | R/L    | X      | X      |
| Function Set                  | 0  | 0  | 0     | 0      | 1      | IF     | N      | X      | X      | X      |
| CGRAM Address Setting         | 0  | 0  | 0     | 1      | ACG[5] | ACG[4] | ACG[3] | ACG[2] | ACG[1] | ACG[0] |
| DDRAM Address Setting         | 0  | 0  | 1     | ADD[6] | ADD[5] | ADD[4] | ADD[3] | ADD[2] | ADD[1] | ADD[0] |
| Busy Flag & Address Reading   | 0  | 1  | BF    | AC[6]  | AC[5]  | AC[4]  | AC[3]  | AC[2]  | AC[1]  | AC[0]  |
| Busy Writing to CG or DDRAM   | 1  | 0  | WD[7] | WD[6]  | WD[5]  | WD[4]  | WD[3]  | WD[2]  | WD[1]  | WD[0]  |
| Data Reading from CG or DDRAM | 1  | 1  | RD[7] | RD[6]  | RD[5]  | RD[4]  | RD[3]  | RD[2]  | RD[1]  | RD[0]  |

* WD: Write Data
* RD: Read Data
* ACG: CGRAM Address
* ADD: DDRAM Address
* AC: Address Counter
* I/D = 1: Increment
* I/D = 0: Decrement

### DDRAM Address

| 행  | 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    | 10   | 11   | 12   | 13   | 14   | 15   | 16   |
|----|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|------|
| 1행 | 0x00 | 0x01 | 0x02 | 0x03 | 0x04 | 0x05 | 0x06 | 0x07 | 0x08 | 0x09 | 0x0A | 0x0B | 0x0C | 0x0D | 0x0E | 0x0F |
| 2행 | 0x40 | 0x41 | 0x42 | 0x43 | 0x44 | 0x45 | 0x46 | 0x47 | 0x48 | 0x49 | 0x4A | 0x4B | 0x4C | 0x4D | 0x4E | 0x4F |

### 커스텀 문자 대역
00H~0FH의 영역에는 사용자 정의문자를 저장할 수 있으며 5x8의 크기를 가진다.
최대 8개의 문자를 정의할 수 있다.

## 커스텀 폰트

각 커스텀 폰트는 5x8의 크기를 가지며, 다음과 같다:

### 1. 공룡 걷기 (1)

```
b00110
b00111
b00100
b00110
b01100
b11100
b11100
b10100
```

### 2. 공룡 걷기 (2)

```
b01100
b01110
b01000
b01110
b01100
b11100
b11100
b01000
```

### 3. 공룡 점프

```
b00110
b00111
b01110
b11110
b11100
b01000
b00000
b00000
```

### 4. 장애물 (1)

```
b00100
b10100
b10101
b10101
b01101
b00110
b00100
b00100
```

### 5. 장애물 (2)

```
b00000
b00100
b00101
b10101
b10101
b10110
b01100
b00100
```
